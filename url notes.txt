COURSE_URL/TAB_NAME/TAB_SPECIFIC_SPLAT


slugs: avoid [1lo0]
	no vowels? no tits!
	
packages can register themselves as content providers
packages specify their tabs and handlers for splats under those tab urls

COURSE_URL/lectures
COURSE_URL/lectures/###/
COURSE_URL/lectures/###/pages/###/

COURSE_URL/nuggets/
COURSE_URL/nuggets/###/
COURSE_URL/nuggets/###/pages/###/
COURSE_URL/nuggets/###/quiz/
COURSE_URL/nuggets/###/quiz/###/

VIEWS <-> USER URLS
MODELS <-> API URLS


view B contained within view A = url B descendant of url A

view can be hidden/shown

every view is responsible for keeping track of its child views
	however, central way to, e.g., "close" a view and all children might be good

every view has a url chunk associated with it, as well as a reference to its parent
	to get the full url, it recursively calls the parents:
		get_url: => @parent.get_url() + @url
		(perhaps use path-joining code?)

all views, upon rendering, should bind to listen to all A-HREFs
	internal urls should be passed through routing
	external urls should be logged and then opened in a new tab/window



ViewRouter
	routes:
		"urlstuff": "mymethod"

	mymethod: ->



lecture
	a) checked to see if url ends -- if so, display lecture list
:lecture_id
	b) render LectureView, and lazy-load its Model's full content from server, load Page
page/:page_id
	c) pagenav is updated, and content block is lazy-loaded

(c) cannot happen until (b) is fully finished (when the subpages are known)
	use a model to represent current url (segment), so it can be checked upon the completion of the parent view, at which point the parent view will listen for further changes to the url

why does the router need to be part of the view?
	want the view to know its own URL, so that when it renders itself, it can include relative urls
		but the router can tell the view what its own url is...
	if views contain views, we want the router to be relative to the parent view, so should be in the view
	(e.g. can't just have one router for Page, since it occurs in multiple contexts)
		ok, I'm convinced... routers should be part of views

course view
	* creates lecture view, assignment view, nugget view
		these "top level views", upon instantiation, can also do things like create tabs
		they also register their routes (or rather, just contain their own subrouters)
	* when it has a url fragment to delegate, it loops over its child views, and checks if they have subrouters, and if so, tries to navigate using them, stopping when it finds a matching route
		it then loops over all views and "hides" all but the target one, "show"ing it (maybe it can first check if it's already shown, and not bother looping in that case)
	* Lecture view, when instantiated, has a router that can instantiate the LectureList view or the LectureDetail view, and put them in at the top level as needed


Model:
	canonical representation of state
	synchronize state with the server
	provide events for state changes
View:
	represent a unit of UI, rendering it and listening for user interaction
	listen to a Model and change in response
Router:
	listen for URL changes and create/render/show/hide Views in response

Unknown:
	trigger lazy-loading of related models (View?)
	save denormalized models to both embedded and collection-level locations
		Model passes in {_denormed_fields: [], _collection_url: "/lecture/345"}
	pass Model data down from one View to the children
		can be done in the Router, upon creation of a View, if desired
		as a fallback, if a View has no model, it can pull it from its parent view's model, using the default field name (@parent.model.get("page"))



perhaps subviews should be a collection; then, we can listen for when a subview is added, and fire off a navigate event on it, in case it cares about the splat
	however, we only need to do a navigate on a visible subview, so perhaps this could just be done in the subview's init process